# Chapter2 算法入门
**著名的瑞士科学家N.Wirth教授提出：数据结构+算法＝程序。数据结构是程序的骨架，算法是程序的灵魂**
## 2.2 贪心算法
英语：greedy algorithm，又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。
**基本步骤**:

1. 从某个初始解出发
2. 采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模;
3. 将所有解综合起来

### 2.2.1 最优装载问题
[有一天，海盗们截获了一艘装满各种各样古董的货船，每件古董都价值连城，一旦打碎就失去了价值。虽然海盗船足够大，但载重为c = 30，每件古董的重量为wi，海盗们绞尽脑汁要把尽可能多的宝贝装上海盗船，该怎么办呢]


| 重量w[i] | 4    | 10   | 7    | 11   | 3    | 5    | 14   | 2    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

贪心策略是每次都选择重量最小的古董装入海盗船，因此可以按照股东的重量非递减排序，排序后如下表所示

| 重量w[i] | 2    | 3    | 4    | 5    | 7    | 10   | 11   | 14   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

## 2.3 分治算法

分治算法其本质就是将一个大规模的问题分解为若干规模较小的相同子问题

**基本过程**：

1. 分解：将原问题分解为若干规模较小、相互独立且与原问题形式相同的子问题
2. 治理：求解各个子问题。由于各个子问题与原问题形式相同，只是规模较小，所以当子问题划分得足够小时，就可以用较简单的方法解决
3. 合并：按原问题的要求，将子问题的解逐层合并成原问题的解

### 2.3.1 合并排序
代码[2_02](2_02.cpp)

在数列排序中，如果只有一个数，那么它本身就是有序的；如果只有两个数，那么进行一次比较就可以完成排序。也就是说，数越少，排序越容易。那么，对于一个由大量数据组成的数列，我们很难一次完成排序，这时可将其分解为小的数列，一直分解到只剩一个数时，本身已有序，再把这些有序的数列合并在一起，执行一个和分解相反的过程，从而完成对整个序列的排序。

给定一个数列(42,15,20,6,8,38,50,12),执行合并排序的过程如下图所示

![image-20220328154227540](https://gitee.com/qiu-mind/blog_image1/raw/master/image-20220328154227540.png)

### 2.3.2 快速排序
代码[2_03](2_03.cpp)

基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

![img](https://gitee.com/qiu-mind/blog_image1/raw/master/1932104-85f1d78294024c5b.jpg)

一般来说，基准元素的选取有以下几种方法：

- 取第一个元素
- 取最后一个元素

- 取中间位置的元素
- 取第一个元素，最后一个元素，中间位置的元素三者的中位数
- 取第一个元素和最后一个元素之间位置的随机数k
